{% extends "base.html" %}<!---->
{% block title %}{{ file.name }}{% endblock %}<!---->
{% block content %}
<div style="display: flex; flex-direction: row; max-height: 100vh;">
  <div id="table_div" style="flex: 1 1;"></div>
  <div id="chart_div" style="flex: 2;"></div>
</div>

<script
  type="text/javascript"
  src="https://www.gstatic.com/charts/loader.js"
></script>
<script type="text/javascript">
  const data = JSON.parse(`{{ data|safe }}`);
  const timeCodeToDate = timeCode => {
    const [hours, minutes, secondsAndMilliseconds] = timeCode.split(":");
    const [seconds, milliseconds] = secondsAndMilliseconds.split(".");
    const date = new Date(
      0,
      0,
      0,
      Number.parseInt(hours),
      Number.parseInt(minutes),
      Number.parseInt(seconds),
      Number.parseInt(milliseconds)
    );
    return date;
  };
  google.charts.load("current", { packages: ["table", "timeline"] });

  // Set a callback to run when the Google Visualization API is loaded.
  google.charts.setOnLoadCallback(() => {
    const container = document.querySelector("#chart_div");
    const chart = new google.visualization.Timeline(container);
    const dataTable = new google.visualization.DataTable();
    dataTable.addColumn({
      type: "string",
      id: "Classification",
      label: "Classification"
    });
    dataTable.addColumn({ type: "string", id: "Model", label: "Model" });
    dataTable.addColumn({ type: "date", id: "Start", label: "Start" });
    dataTable.addColumn({ type: "date", id: "End", label: "End" });
    const groundTruthData = Object.keys(data.groundTruth.timecodes)
      .map(timecode => {
        return data.groundTruth.timecodes[timecode].map(prediction => {
          prediction["timecode"] = timecode;
          return prediction;
        });
      })
      .reduce((flattened, list) => flattened.concat(list))
      .map(prediction => {
        return {
          label: prediction.tag,
          model: "Foobar",
          startDate: timeCodeToDate(prediction.timecode),
          endDate: timeCodeToDate(prediction.timecode)
        };
      });
    console.log(
      groundTruthData.map(data => [
        data.label,
        data.model,
        data.startDate,
        data.endDate
      ])
    );
    dataTable.addRows(
      groundTruthData.map(data => [
        data.label,
        data.model,
        data.startDate,
        data.endDate
      ])
    );

    const options = {
      timeline: { showRowLabels: true },
      avoidOverlappingGridLines: true
    };

    chart.draw(dataTable, options);
  });

  google.charts.setOnLoadCallback(() => {
    const container = document.querySelector("#table_div");
    const chart = new google.visualization.Table(container);
    const dataTable = new google.visualization.DataTable();

    dataTable.addColumn("string", "Classification");
    dataTable.addColumn("string", "Model");
    dataTable.addColumn("date", "Start");
    dataTable.addColumn("date", "End");
    const groundTruthData = Object.keys(data.groundTruth.timecodes)
      .map(timecode => {
        return data.groundTruth.timecodes[timecode].map(prediction => {
          prediction["timecode"] = timecode;
          return prediction;
        });
      })
      .reduce((flattened, list) => flattened.concat(list))
      .map(prediction => {
        return {
          label: prediction.tag,
          model: "Foobar",
          startDate: timeCodeToDate(prediction.timecode),
          endDate: timeCodeToDate(prediction.timecode)
        };
      });
    dataTable.addRows(
      groundTruthData.map(data => [
        data.label,
        data.model,
        data.startDate,
        data.endDate
      ])
    );

    const options = {
      width: "100%",
      height: "100%"
    };

    chart.draw(dataTable, options);
  });
</script>
{% endblock %}
